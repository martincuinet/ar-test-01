<html>
  <head>
    <meta charset="utf-8" />
    <title>Myself At Home</title>
    <meta name="description" content="" />
     
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    <script src="//cdn.rawgit.com/donmccurdy/aframe-extras/v3.8.4/dist/aframe-extras.min.js"></script>
    <script src="https://rawgit.com/donmccurdy/aframe-extras/master/dist/aframe-extras.loaders.min.js"></script>
    <script>
      AFRAME.registerShader('grid-glitch', {
        schema: {
          color: { type: 'color', is: 'uniform' },
          timeMsec: { type: 'time', is: 'uniform' }
        },
        vertexShader: `
          uniform mat4 boneMatrices[MAX_BONES];
          attribute vec4 skinIndex;
          attribute vec4 skinWeight;
          varying vec2 vUv;
  
          void main() {
            vUv = uv;
            vec4 skinned = vec4(0.0);
            for (int i = 0; i < 4; i++) {
              vec4 transformed = boneMatrices[int(skinIndex[i])] * vec4(position, 1.0);
              skinned += skinWeight[i] * transformed;
            }
            gl_Position = projectionMatrix * modelViewMatrix * skinned;
          }
        `,
        fragmentShader: `
          varying vec2 vUv;
          uniform vec3 color;
          uniform float timeMsec;
          void main() {
            float time = timeMsec / 1000.0;
            gl_FragColor = mix(
              vec4(mod(vUv, 0.05) * 20.0, 1.0, 1.0),
              vec4(color, 1.0),
              sin(time)
            );
          }
        `
      });
  
      AFRAME.registerComponent('apply-grid-glitch-shader', {
        schema: {
          color: { type: 'color', default: '#00f' }
        },
        init: function () {
          this.el.addEventListener('model-loaded', () => {
            const model = this.el.getObject3D('mesh');
            if (!model) return;
            model.traverse(node => {
              if (node.isMesh) {
                node.material = new THREE.ShaderMaterial({
                  uniforms: {
                    color: { value: new THREE.Color(this.data.color) },
                    timeMsec: { value: 0 }
                  },
                  vertexShader: AFRAME.shaders['grid-glitch'].vertexShader,
                  fragmentShader: AFRAME.shaders['grid-glitch'].fragmentShader,
                  skinning: true
                });
                node.material.needsUpdate = true;
              }
            });
          });
        },
        tick: function (time) {
          const model = this.el.getObject3D('mesh');
          if (model) {
            model.traverse(node => {
              if (node.isMesh && node.material.uniforms && node.material.uniforms.timeMsec) {
                node.material.uniforms.timeMsec.value = time;
              }
            });
          }
        }
      });
    </script>
  </head>
  <body style="margin : 0px; overflow: hidden;">
 
    <a-scene embedded arjs='sourceType: webcam; ' vr-mode-ui="enabled: false;">
           
      <a-marker type ="pattern" url = "./src/pattern-logo.patt">       
         <a-entity 
         position="0 0 0" 
         scale="50 50 50" 
         gltf-model= "./src/drunk.gltf" 
         animation-mixer 
         loop="true" 
         apply-grid-glitch-shader = "color: blue;"
         >
          </a-entity> 

         <a-plane 
         position="-0.02 0 0" 
         rotation="-90 0 0" 
         scale="1.2 1.2 1.2" 
         material="shader:grid-glitch"
         >
        </a-plane>
      </a-marker>
      <a-entity camera ></a-entity>            
    </a-scene>
  </body>
</html>